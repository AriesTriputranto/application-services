//
// UniFFI interface definition for the "places" component.
//
// The "places" component is still in the process of being converted
// to UniFFI, so this file doesnt' define the entire interface.
// For now it only contains the rich datatypes that we want to
// transfer across the FFI boundary.


namespace places {};

enum VisitTransition {
    /** This transition type means the user followed a link. */
    "Link",
    /** This transition type means that the user typed the page's URL in the
     *  URL bar or selected it from UI (URL bar autocomplete results, etc).
     */
     "Typed",
     "Bookmark",
     "Embed",
     "RedirectPermanent",
     "RedirectTemporary",
     "Download",
     "FramedLink",
     "Reload"
};

// Information about a specific history visit.
//
dictionary HistoryVisitInfo {
    string url;
    string? title;
    i64 timestamp;
    VisitTransition visit_type;
    boolean is_hidden;
};

// A list of history visits, along with pagination info.
// This is useful when loading lots of history visits via pagination.
//
dictionary HistoryVisitInfosWithBound {
    sequence<HistoryVisitInfo> infos;
    i64 bound;
    i64 offset;
};


enum BookmarkType {
    "Bookmark",
    "Folder",
    "Separator"
};


/**
 * A bookmark node.
 *
 * We use a single message type for bookmarks. It covers insertion, deletion,
 * and update, and represents all three bookmark types.
 *
 * This simplifies the FFI by reducing the number of types that must go across
 * it, and retuces boilderplate, but removes some static-ish guarantees we
 * might have otherwise.
 *
 * Note that these docs comments are internal, and don't necessarily impact the actual
 * API we expose to Kotlin/Swift (this is particularly true around reads).
 */
dictionary BookmarkNode {
    /**
     * The type of this bookmark, a `BookmarkType` (from `types.rs`).
     *
     * This impacts which fields may be present.
     *
     * It's illegal to attempt to change this when updating a bookmark.
     *
     * Note: this probably should be an `enum`, but prost seems to get upset
     * about it so we're just using int32 for now.
     *
     * Note: this is `node_type` and not `type` because `type` is reserved
     * in Rust.
     *
     * - Always returned on reads.
     
     * - Required for inserts.
     * - Not provided for updates.
     */
    BookmarkType? node_type;

    /**
     * The bookmark's guid.
     *
     * - Always returned on reads.
     * - Not allowed for inserts.
     * - Required for updates (specifies which record is being changed)
     */
    string? guid;

    /**
     * Creation time, in milliseconds since the unix epoch.
     *
     * May not be a local timestamp, and may shift if new devices are able to
     * provide an earlier (but still valid) timestamp.
     *
     * - Always returned on reads.
     * - Ignored for insertion and update.
     */
    i64? date_added;

    /**
     * Last modification time, in milliseconds since the unix epoch.
     *
     * - Always returned on reads.
     * - Ignored for insertion and update.
     */
    i64? last_modified;

    /**
     * Guid of the parent record.
     *
     * - Returned on reads, except for reads of the bookmark root.
     * - Required for insertion.
     * - On updates, if provided, we treat it as a move.
     *     - Interacts with `position`, see its documentation below
     *       for details on how.
     */
    string? parent_guid;

    /**
     * Zero based index within the parent.
     *
     * - Not provided on reads (for now).
     *
     * - Allowed for insertion.
     *    - Leaving it out means 'end of folder'.
     *
     * - Allowed for updates.
     *     - If `parent_guid` is not provided and `position` is, we treat this
     *       a move within the same folder.
     *
     *     - If `parent_guid` and `position` are both provided, we treat this as
     *       a move to / within that folder, and we insert at the requested
     *       position.
     *
     *     - If `position` is not provided (and `parent_guid` is) then it's
     *       treated as a move to the end of that folder.
     */
    i32? position;

    /**
     * Bookmark title. Not present for type = `BookmarkType::Separator`.
     *
     * - Returned on reads if it exists.
     * - Required when inserting folders.
     */
    string? title;

    /**
     * Bookmark URL. Only allowed/present for type = `BookmarkType::Bookmark`.
     *
     * - Always returned on reads (for `BookmarkType::Bookmark`).
     * - Required when inserting a new bookmark.
     */
    string? url;

    /**
     * IDs of folder children, in order. Only present for type =
     * `BookmarkType::Folder`.
     *
     * - Returned on reads (for `BookmarkType::Folder`).
     * - Forbidden for insertions and updates.
     * - Not provided if `child_nodes` is provided, to avoid sending more data
     *   over the FFI than necessary.
     */
    sequence<string> child_guids;

    /**
     * Data about folder children, in order. Only present for type =
     * `BookmarkType::Folder`.
     *
     * For performance reasons, this only is provided if it's requested.
     */
    sequence<BookmarkNode>? child_nodes;
};

[Enum]
interface MatchReason {
    // Never used in practice. Maybe remove this from here and from the rust enum?
    Keyword();
    Origin();
    Url();
    PreviousUse();
    Bookmark();
    // If we get real tag support, just add `string? tags` to SearchResult below, but
    // for now expose that it was because of tags.
    Tags(string tags);
};

dictionary SearchResult {
    string search_string;
    string url;
    string title;
    string? icon_url;
    i64 frecency;
    sequence<MatchReason> reasons;
};


dictionary TopFrecentSiteInfo {
    string url;
    string? title;
};

// This just makes sure we have some extra helper functions available,
// to be called from our hand-written bindings.
dictionary TypesThatWouldAppearInFunctionSignaturesIfWeUniffiedTheFunctions {
    sequence<SearchResult> search_results;
    sequence<TopFrecentSiteInfo> frecency_results;
};